# SPDX-License-Identifier: BSD-3-Clause
# Copyright (c) 2021-2025, ðŸ€â˜€ðŸŒ•ðŸŒ¥ ðŸŒŠ
#
# Build, sign, notarize, and release OSX Cleaner GUI app

name: Release GUI App

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      version:
        description: 'Version number (e.g., 1.0.0)'
        required: false
        default: ''
      skip_notarization:
        description: 'Skip notarization (for testing)'
        type: boolean
        default: false

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1
  APP_NAME: "OSX Cleaner"

permissions:
  contents: write

jobs:
  build-and-notarize:
    name: Build and Notarize
    runs-on: macos-14

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Determine version
        id: version
        run: |
          if [[ -n "${{ github.event.inputs.version }}" ]]; then
            VERSION="${{ github.event.inputs.version }}"
          elif [[ "${GITHUB_REF}" == refs/tags/v* ]]; then
            VERSION="${GITHUB_REF#refs/tags/v}"
          else
            VERSION="0.0.0-dev"
          fi
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "Building version: ${VERSION}"

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable

      - name: Cache Cargo registry
        uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/registry
            ~/.cargo/git
            rust-core/target
          key: ${{ runner.os }}-cargo-release-${{ hashFiles('rust-core/Cargo.lock') }}
          restore-keys: |
            ${{ runner.os }}-cargo-release-
            ${{ runner.os }}-cargo-

      - name: Cache Swift packages
        uses: actions/cache@v4
        with:
          path: .build
          key: ${{ runner.os }}-swift-release-${{ hashFiles('Package.resolved') }}
          restore-keys: |
            ${{ runner.os }}-swift-release-
            ${{ runner.os }}-swift-

      - name: Setup code signing
        env:
          CERTIFICATE_BASE64: ${{ secrets.CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.CERTIFICATE_PASSWORD }}
        run: |
          # Skip if no certificate is configured
          if [[ -z "${CERTIFICATE_BASE64}" ]]; then
            echo "No signing certificate configured, will use ad-hoc signing"
            exit 0
          fi

          # Create variables
          CERTIFICATE_PATH="${RUNNER_TEMP}/certificate.p12"
          KEYCHAIN_PATH="${RUNNER_TEMP}/build.keychain-db"
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Import certificate from base64
          echo "${CERTIFICATE_BASE64}" | base64 --decode > "${CERTIFICATE_PATH}"

          # Create temporary keychain
          security create-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"
          security set-keychain-settings -lut 21600 "${KEYCHAIN_PATH}"
          security unlock-keychain -p "${KEYCHAIN_PASSWORD}" "${KEYCHAIN_PATH}"

          # Import certificate to keychain
          security import "${CERTIFICATE_PATH}" \
            -P "${CERTIFICATE_PASSWORD}" \
            -A \
            -t cert \
            -f pkcs12 \
            -k "${KEYCHAIN_PATH}"

          # Set partition list for codesigning
          security set-key-partition-list \
            -S apple-tool:,apple: \
            -s \
            -k "${KEYCHAIN_PASSWORD}" \
            "${KEYCHAIN_PATH}"

          # Add keychain to search list
          security list-keychains -d user -s "${KEYCHAIN_PATH}"

          # Export environment for later steps
          echo "KEYCHAIN_PATH=${KEYCHAIN_PATH}" >> $GITHUB_ENV
          echo "KEYCHAIN_PASSWORD=${KEYCHAIN_PASSWORD}" >> $GITHUB_ENV

          # List available signing identities
          echo "Available signing identities:"
          security find-identity -v -p codesigning "${KEYCHAIN_PATH}"

      - name: Build Rust core
        run: |
          cd rust-core
          cargo build --release

      - name: Build and sign app
        env:
          VERSION: ${{ steps.version.outputs.version }}
          BUILD_NUMBER: ${{ github.run_number }}
          DEVELOPMENT_TEAM: ${{ secrets.DEVELOPMENT_TEAM }}
        run: |
          # Determine signing option
          if [[ -n "${KEYCHAIN_PATH}" ]]; then
            ./scripts/appstore/build-app.sh --sign --version "${VERSION}" --build "${BUILD_NUMBER}"
          else
            ./scripts/appstore/build-app.sh --version "${VERSION}" --build "${BUILD_NUMBER}"
          fi

      - name: Verify code signature
        run: |
          APP_PATH=".build/appstore/${APP_NAME}.app"

          echo "Verifying code signature..."
          codesign --verify --verbose=4 "${APP_PATH}" || echo "Warning: Signature verification failed"

          echo "Checking entitlements..."
          codesign -d --entitlements - "${APP_PATH}" 2>/dev/null || true

      - name: Notarize app
        if: ${{ !inputs.skip_notarization && secrets.APPLE_ID != '' }}
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          APP_PATH=".build/appstore/${APP_NAME}.app"
          NOTARIZE_ZIP=".build/appstore/${APP_NAME}-notarize.zip"

          echo "Creating archive for notarization..."
          ditto -c -k --keepParent "${APP_PATH}" "${NOTARIZE_ZIP}"

          echo "Submitting to Apple notarization service..."
          xcrun notarytool submit "${NOTARIZE_ZIP}" \
            --apple-id "${APPLE_ID}" \
            --team-id "${APPLE_TEAM_ID}" \
            --password "${APPLE_APP_SPECIFIC_PASSWORD}" \
            --wait

          echo "Stapling notarization ticket..."
          xcrun stapler staple "${APP_PATH}"

          echo "Validating stapled ticket..."
          xcrun stapler validate "${APP_PATH}"

          # Cleanup
          rm -f "${NOTARIZE_ZIP}"

          echo "Notarization complete!"

      - name: Create DMG
        env:
          VERSION: ${{ steps.version.outputs.version }}
        run: |
          if [[ -n "${KEYCHAIN_PATH}" ]]; then
            ./scripts/appstore/create-dmg.sh --sign --version "${VERSION}"
          else
            ./scripts/appstore/create-dmg.sh --version "${VERSION}"
          fi

      - name: Notarize DMG
        if: ${{ !inputs.skip_notarization && secrets.APPLE_ID != '' }}
        env:
          VERSION: ${{ steps.version.outputs.version }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
        run: |
          DMG_PATH=".build/appstore/OSXCleaner-${VERSION}.dmg"

          echo "Submitting DMG for notarization..."
          xcrun notarytool submit "${DMG_PATH}" \
            --apple-id "${APPLE_ID}" \
            --team-id "${APPLE_TEAM_ID}" \
            --password "${APPLE_APP_SPECIFIC_PASSWORD}" \
            --wait

          echo "Stapling DMG..."
          xcrun stapler staple "${DMG_PATH}"

          echo "DMG notarization complete!"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: OSXCleaner-GUI-${{ steps.version.outputs.version }}
          path: |
            .build/appstore/*.dmg
            .build/appstore/*.app
          retention-days: 30

      - name: Create GitHub Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v2
        with:
          files: .build/appstore/*.dmg
          generate_release_notes: true
          draft: false
          prerelease: ${{ contains(github.ref, '-') }}
          body: |
            ## OSX Cleaner ${{ steps.version.outputs.version }}

            ### Installation
            1. Download `OSXCleaner-${{ steps.version.outputs.version }}.dmg`
            2. Open the DMG file
            3. Drag "OSX Cleaner" to Applications

            ### Requirements
            - macOS 14.0 or later

            ### Verification
            The app is signed and notarized by Apple.

      - name: Cleanup keychain
        if: always()
        run: |
          if [[ -n "${KEYCHAIN_PATH}" ]]; then
            security delete-keychain "${KEYCHAIN_PATH}" || true
          fi
