/* Auto-generated by cbindgen. Do not edit. */

#ifndef OSXCORE_H
#define OSXCORE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Result returned by FFI functions
 */
typedef struct osx_FFIResult {
    bool success;
    char *error_message;
    char *data;
} osx_FFIResult;

/**
 * macOS version representation
 *
 * Stores major, minor, and patch version numbers (e.g., 15.1.0 for Sequoia 15.1)
 */
typedef struct osx_Version {
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
} osx_Version;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the Rust core library
 *
 * # Safety
 * This function initializes the logger and should be called once at startup.
 */
bool osx_core_init(void);

/**
 * Get the version of the Rust core library
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_core_version(void);

/**
 * Analyze a path for cleanup opportunities
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_analyze_path(const char *path);

/**
 * Calculate safety level for a path
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 */
int32_t osx_calculate_safety(const char *path);

/**
 * Clean a path with the specified cleanup level
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - `cleanup_level` is 1-4 (Light, Normal, Deep, System)
 * - `dry_run` if true, no files will be deleted
 */
struct osx_FFIResult osx_clean_path(const char *path,
                                    int32_t cleanup_level,
                                    bool dry_run);

/**
 * Free a string allocated by Rust
 *
 * # Safety
 * - `s` must be a pointer returned by a Rust FFI function
 * - `s` must not be used after this call
 */
void osx_free_string(char *s);

/**
 * Free an FFIResult
 *
 * # Safety
 * - `result` must be a valid pointer to an FFIResult
 */
void osx_free_result(struct osx_FFIResult *result);

/**
 * Get disk space information for the root filesystem
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded DiskSpace struct
 */
struct osx_FFIResult osx_get_disk_space(void);

/**
 * Analyze home directory and get top N directories by size
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<DirectoryInfo>
 */
struct osx_FFIResult osx_analyze_home(int32_t top_n);

/**
 * Analyze application caches
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<CacheInfo>
 */
struct osx_FFIResult osx_analyze_caches(void);

/**
 * Analyze developer tool components
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<DeveloperComponentInfo>
 */
struct osx_FFIResult osx_analyze_developer(void);

/**
 * Estimate cleanable space
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded CleanableEstimate
 */
struct osx_FFIResult osx_estimate_cleanable(void);

/**
 * Perform full disk analysis
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded AnalysisResult
 */
struct osx_FFIResult osx_full_analysis(void);

/**
 * Get system information as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_system_info(void);

/**
 * Get macOS version string (e.g., "15.1.0")
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_macos_version(void);

/**
 * Get macOS codename (e.g., "Sequoia")
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_macos_codename(void);

/**
 * Get CPU architecture (0=AppleSilicon, 1=Intel, 2=Unknown)
 */
int32_t osx_architecture(void);

/**
 * Check if running on Apple Silicon
 */
bool osx_is_apple_silicon(void);

/**
 * Check if Rosetta 2 is installed
 */
bool osx_is_rosetta_installed(void);

/**
 * Check if current process is running under Rosetta
 */
bool osx_is_running_under_rosetta(void);

/**
 * Check if SIP (System Integrity Protection) is enabled
 */
bool osx_is_sip_enabled(void);

/**
 * Check if version is at least the specified version
 */
bool osx_is_version_at_least(uint32_t major,
                             uint32_t minor);

/**
 * Get version-specific paths as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_version_specific_paths(void);

/**
 * Get special cleanup targets for the current version as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_special_targets(void);

/**
 * Check if the current version has a known bug
 *
 * # Safety
 * - `bug_name` must be a valid null-terminated C string
 */
bool osx_has_known_bug(const char *bug_name);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* OSXCORE_H */
