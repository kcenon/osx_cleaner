/* Auto-generated by cbindgen. Do not edit. */

#ifndef OSXCORE_H
#define OSXCORE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Result returned by FFI functions
 */
typedef struct osx_FFIResult {
    bool success;
    char *error_message;
    char *data;
} osx_FFIResult;

/**
 * macOS version representation
 *
 * Stores major, minor, and patch version numbers (e.g., 15.1.0 for Sequoia 15.1)
 */
typedef struct osx_Version {
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
} osx_Version;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the Rust core library
 *
 * # Safety
 * This function initializes the logger and should be called once at startup.
 */
bool osx_core_init(void);

/**
 * Get the version of the Rust core library
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_core_version(void);

/**
 * Analyzes the specified path for cleanup opportunities.
 *
 * This function scans the given path and returns information about files
 * that can be safely cleaned up, organized by category and safety level.
 *
 * # Arguments
 *
 * * `path` - A pointer to a null-terminated C string containing the path to analyze.
 *   Must be a valid UTF-8 encoded path.
 *
 * # Returns
 *
 * Returns an `FFIResult` struct containing:
 * - On success: `success = true`, `data` contains JSON-encoded analysis results
 * - On failure: `success = false`, `error_message` contains error description
 *
 * # Safety
 *
 * This function is unsafe because it dereferences raw pointers.
 *
 * ## Preconditions
 *
 * The caller MUST ensure:
 * - `path` is a valid, non-null pointer to a null-terminated C string
 * - `path` remains valid for the entire duration of this function call
 * - `path` points to a valid UTF-8 encoded string
 *
 * ## Postconditions
 *
 * After this function returns:
 * - The returned `FFIResult` is owned by the caller
 * - The caller MUST call `osx_free_result()` to free the returned result
 * - The `path` pointer is no longer referenced and can be freed by the caller
 *
 * ## Thread Safety
 *
 * This function is thread-safe. Multiple threads may call this function
 * concurrently with different paths. However, calling with the same path
 * from multiple threads may result in redundant work.
 *
 * ## Undefined Behavior
 *
 * The following will cause undefined behavior:
 * - Passing a null pointer for `path`
 * - Passing a pointer to non-null-terminated data
 * - Passing a pointer to invalid memory
 * - Using the returned pointers after calling `osx_free_result()`
 * - Calling `osx_free_result()` more than once on the same result
 *
 * # Example (Swift)
 *
 * ```swift
 * func analyzeDirectory(_ path: String) throws -> AnalysisResult {
 *     let cPath = path.cString(using: .utf8)!
 *     let result = osx_analyze_path(cPath)
 *     defer { osx_free_result(result) }
 *
 *     guard result.success else {
 *         let error = String(cString: result.error_message)
 *         throw AnalysisError.failed(error)
 *     }
 *
 *     let json = String(cString: result.data)
 *     return try JSONDecoder().decode(AnalysisResult.self, from: json.data(using: .utf8)!)
 * }
 * ```
 *
 * # Example (C)
 *
 * ```c
 * FFIResult result = osx_analyze_path("/Users/example/Library/Caches");
 * if (result.success) {
 *     printf("Analysis: %s\n", result.data);
 * } else {
 *     fprintf(stderr, "Error: %s\n", result.error_message);
 * }
 * osx_free_result(result);
 * ```
 */
struct osx_FFIResult osx_analyze_path(const char *path);

/**
 * Calculate safety level for a path
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 */
int32_t osx_calculate_safety(const char *path);

/**
 * Check if a path is protected (DANGER level - never delete)
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is protected, false otherwise
 */
bool osx_is_protected(const char *path);

/**
 * Classify a path and return detailed information as JSON
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"path": "...", "level": "...", "level_value": N, "reason": "...", "is_deletable": bool}
 */
struct osx_FFIResult osx_classify_path(const char *path);

/**
 * Validate multiple paths in batch
 *
 * # Safety
 * - `paths_json` must be a valid null-terminated C string containing a JSON array of paths
 * - `cleanup_level` is 1-4 (Light, Normal, Deep, System)
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array of validation results
 */
struct osx_FFIResult osx_validate_batch(const char *paths_json,
                                        int32_t cleanup_level);

/**
 * Validate a single cleanup operation
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - `cleanup_level` is 1-4 (Light, Normal, Deep, System)
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_validate_cleanup(const char *path,
                                          int32_t cleanup_level);

/**
 * Executes cleanup operations on the specified path.
 *
 * This function performs file deletion based on the specified cleanup level
 * and safety validation. It supports dry-run mode for previewing changes.
 *
 * # Arguments
 *
 * * `path` - A pointer to a null-terminated C string containing the path to clean.
 *   Must be a valid UTF-8 encoded path.
 * * `cleanup_level` - Cleanup intensity level (1-4):
 *   - 1: Light - Only user caches (SAFE level)
 *   - 2: Normal - User caches + logs (SAFE + LOW_RISK levels)
 *   - 3: Deep - Includes old files (SAFE + LOW_RISK + MEDIUM_RISK levels)
 *   - 4: System - Everything except DANGER (use with extreme caution)
 * * `dry_run` - If `true`, simulates deletion without actually removing files.
 *
 * # Returns
 *
 * Returns an `FFIResult` struct containing:
 * - On success: `success = true`, `data` contains JSON with deletion statistics
 * - On failure: `success = false`, `error_message` contains error description
 *
 * # Safety
 *
 * This function is unsafe because:
 * - It dereferences raw pointers
 * - It may perform destructive file system operations
 * - Incorrect usage can lead to data loss
 *
 * ## Preconditions
 *
 * The caller MUST ensure:
 * - `path` is a valid, non-null pointer to a null-terminated C string
 * - `path` remains valid for the entire duration of this function call
 * - `path` points to a valid UTF-8 encoded string
 * - `cleanup_level` is in range 1-4 (values outside this range may cause errors)
 * - Files at `path` are not in use by critical applications (in production mode)
 *
 * ## Postconditions
 *
 * After this function returns:
 * - The returned `FFIResult` is owned by the caller
 * - The caller MUST call `osx_free_result()` to free the returned result
 * - If `dry_run == false` and `success == true`, files may have been deleted
 * - Deletion operations are logged (if logging is initialized)
 *
 * ## Thread Safety
 *
 * This function is thread-safe for operations on different paths.
 * **AVOID** calling this function on the same path from multiple threads,
 * as it may cause race conditions in file system operations.
 *
 * ## Data Loss Prevention
 *
 * This function implements multiple safety checks:
 * - Protected paths (system directories) are never deleted
 * - Cloud-synced files are checked before deletion
 * - Running application caches are validated
 * - Files are classified by safety level before deletion
 *
 * ## Undefined Behavior
 *
 * The following will cause undefined behavior:
 * - Passing a null pointer for `path`
 * - Passing a pointer to non-null-terminated data
 * - Passing a pointer to invalid memory
 * - Using the returned pointers after calling `osx_free_result()`
 *
 * # Example (Swift)
 *
 * ```swift
 * func cleanDirectory(_ path: String, level: CleanupLevel, dryRun: Bool) throws -> CleanStats {
 *     let cPath = path.cString(using: .utf8)!
 *     let result = osx_clean_path(cPath, Int32(level.rawValue), dryRun)
 *     defer { osx_free_result(result) }
 *
 *     guard result.success else {
 *         let error = String(cString: result.error_message)
 *         throw CleanupError.failed(error)
 *     }
 *
 *     let json = String(cString: result.data)
 *     return try JSONDecoder().decode(CleanStats.self, from: json.data(using: .utf8)!)
 * }
 * ```
 *
 * # Example (C)
 *
 * ```c
 * // Dry run first
 * FFIResult preview = osx_clean_path("/Users/example/Library/Caches", 2, true);
 * if (preview.success) {
 *     printf("Would delete: %s\n", preview.data);
 *     osx_free_result(preview);
 *
 *     // Confirm and execute
 *     FFIResult actual = osx_clean_path("/Users/example/Library/Caches", 2, false);
 *     if (actual.success) {
 *         printf("Deleted: %s\n", actual.data);
 *     }
 *     osx_free_result(actual);
 * }
 * ```
 */
struct osx_FFIResult osx_clean_path(const char *path,
                                    int32_t cleanup_level,
                                    bool dry_run);

/**
 * Frees a string allocated by Rust.
 *
 * This function deallocates memory for a C string that was created
 * by Rust and returned through the FFI boundary.
 *
 * # Arguments
 *
 * * `s` - A pointer to a null-terminated C string allocated by Rust.
 *
 * # Safety
 *
 * This function is unsafe because:
 * - It assumes `s` was allocated by Rust using `CString::into_raw()`
 * - It transfers ownership of the memory back to Rust for deallocation
 *
 * ## Preconditions
 *
 * The caller MUST ensure:
 * - `s` is either null OR a valid pointer returned by a Rust FFI function
 * - `s` has not been freed previously
 * - `s` has not been modified after allocation (must remain null-terminated)
 *
 * ## Postconditions
 *
 * After this function returns:
 * - The memory pointed to by `s` is deallocated
 * - `s` becomes a dangling pointer and MUST NOT be used
 *
 * ## Undefined Behavior
 *
 * The following will cause undefined behavior:
 * - Passing a pointer not allocated by Rust
 * - Calling this function twice on the same pointer (double-free)
 * - Using `s` after this function returns
 * - Passing a pointer to stack-allocated or static string
 *
 * ## Notes
 *
 * - Passing a null pointer is safe and will be ignored
 * - This function is typically called by `osx_free_result()` and should
 *   rarely be called directly
 */
void osx_free_string(char *s);

/**
 * Frees an FFIResult structure and its contents.
 *
 * This function deallocates all memory associated with an `FFIResult`,
 * including both the `error_message` and `data` fields.
 *
 * # Arguments
 *
 * * `result` - A pointer to an `FFIResult` structure.
 *
 * # Safety
 *
 * This function is unsafe because:
 * - It assumes `result` points to a valid `FFIResult` allocated by Rust
 * - It deallocates the result and all its associated memory
 *
 * ## Preconditions
 *
 * The caller MUST ensure:
 * - `result` is either null OR a valid pointer to an `FFIResult`
 * - `result` has not been freed previously
 * - The `FFIResult` was created by a Rust FFI function
 *
 * ## Postconditions
 *
 * After this function returns:
 * - All memory associated with `result` is deallocated
 * - `result` becomes a dangling pointer and MUST NOT be used
 * - Both `error_message` and `data` pointers are freed
 *
 * ## Thread Safety
 *
 * This function is NOT thread-safe for the same `result`.
 * Multiple threads MUST NOT free the same result concurrently.
 *
 * ## Undefined Behavior
 *
 * The following will cause undefined behavior:
 * - Calling this function twice on the same result (double-free)
 * - Using `result` or its fields after this function returns
 * - Passing a pointer to stack-allocated or improperly initialized `FFIResult`
 *
 * ## Notes
 *
 * - Passing a null pointer is safe and will be ignored
 * - The function frees both `error_message` and `data` if they are non-null
 * - Always use `defer { osx_free_result(result) }` in Swift to ensure cleanup
 *
 * # Example (Swift)
 *
 * ```swift
 * let result = osx_analyze_path(path)
 * defer { osx_free_result(result) }  // Automatic cleanup
 * // Use result...
 * ```
 *
 * # Example (C)
 *
 * ```c
 * FFIResult result = osx_analyze_path("/path");
 * // Use result...
 * osx_free_result(result);  // Manual cleanup
 * ```
 */
void osx_free_result(struct osx_FFIResult *result);

/**
 * Get disk space information for the root filesystem
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded DiskSpace struct
 */
struct osx_FFIResult osx_get_disk_space(void);

/**
 * Analyze home directory and get top N directories by size
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<DirectoryInfo>
 */
struct osx_FFIResult osx_analyze_home(int32_t top_n);

/**
 * Analyze application caches
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<CacheInfo>
 */
struct osx_FFIResult osx_analyze_caches(void);

/**
 * Analyze developer tool components
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<DeveloperComponentInfo>
 */
struct osx_FFIResult osx_analyze_developer(void);

/**
 * Estimate cleanable space
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded CleanableEstimate
 */
struct osx_FFIResult osx_estimate_cleanable(void);

/**
 * Perform full disk analysis
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded AnalysisResult
 */
struct osx_FFIResult osx_full_analysis(void);

/**
 * Initialize the deletion logger with optional file output
 *
 * # Safety
 * - `log_path` may be null for memory-only logging
 * - If not null, must be a valid null-terminated C string
 */
struct osx_FFIResult osx_init_logger(const char *log_path);

/**
 * Get all deletion log entries as JSON
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_get_deletion_logs(void);

/**
 * Get deletion log statistics as JSON
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_get_log_stats(void);

/**
 * Clear all deletion logs from memory
 */
void osx_clear_logs(void);

/**
 * Check if a specific application is running
 *
 * # Safety
 * - `app_name` must be a valid null-terminated C string
 * - Returns true if the application is running, false otherwise
 */
bool osx_is_app_running(const char *app_name);

/**
 * Check if a file or directory is in use by any process
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in use, false otherwise
 */
bool osx_is_file_in_use(const char *path);

/**
 * Check if any application related to a cache path is running
 *
 * # Safety
 * - `cache_path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"running": bool, "app_name": "..." or null}
 */
struct osx_FFIResult osx_check_related_app_running(const char *cache_path);

/**
 * Get a list of all running processes
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array: [{"pid": N, "name": "...", "path": "..." or null}, ...]
 */
struct osx_FFIResult osx_get_running_processes(void);

/**
 * Get processes using a specific file or directory
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array: [{"pid": N, "name": "...", "path": "..." or null}, ...]
 */
struct osx_FFIResult osx_get_processes_using_path(const char *path);

/**
 * Get cache paths associated with a specific application
 *
 * # Safety
 * - `app_name` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array of paths: ["path1", "path2", ...]
 */
struct osx_FFIResult osx_get_app_cache_paths(const char *app_name);

/**
 * Detect which cloud service (if any) a path belongs to
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"service": "iCloud"|"Dropbox"|"OneDrive"|"Google Drive"|null, "is_cloud_path": bool}
 */
struct osx_FFIResult osx_detect_cloud_service(const char *path);

/**
 * Get detailed cloud sync information for a path
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"service": "...", "status": "...", "path": "...", "is_cloud_path": bool}
 * - Status can be: "Synced", "Syncing", "Pending", "CloudOnly", "LocalOnly", "Error", "NotApplicable"
 */
struct osx_FFIResult osx_get_cloud_sync_info(const char *path);

/**
 * Check if a path is safe to delete from a cloud sync perspective
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"safe": bool, "warning": "..." or null}
 * - If not safe, warning explains why (e.g., "File is currently syncing to iCloud")
 */
struct osx_FFIResult osx_is_safe_to_delete_cloud(const char *path);

/**
 * Check if a path is within an iCloud synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in an iCloud location, false otherwise
 */
bool osx_is_icloud_path(const char *path);

/**
 * Check if a path is within a Dropbox synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in a Dropbox location, false otherwise
 */
bool osx_is_dropbox_path(const char *path);

/**
 * Check if a path is within a OneDrive synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in a OneDrive location, false otherwise
 */
bool osx_is_onedrive_path(const char *path);

/**
 * Check if a path is within a Google Drive synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in a Google Drive location, false otherwise
 */
bool osx_is_google_drive_path(const char *path);

/**
 * Get system information as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_system_info(void);

/**
 * Get macOS version string (e.g., "15.1.0")
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_macos_version(void);

/**
 * Get macOS codename (e.g., "Sequoia")
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_macos_codename(void);

/**
 * Get CPU architecture (0=AppleSilicon, 1=Intel, 2=Unknown)
 */
int32_t osx_architecture(void);

/**
 * Check if running on Apple Silicon
 */
bool osx_is_apple_silicon(void);

/**
 * Check if Rosetta 2 is installed
 */
bool osx_is_rosetta_installed(void);

/**
 * Check if current process is running under Rosetta
 */
bool osx_is_running_under_rosetta(void);

/**
 * Check if SIP (System Integrity Protection) is enabled
 */
bool osx_is_sip_enabled(void);

/**
 * Check if version is at least the specified version
 */
bool osx_is_version_at_least(uint32_t major,
                             uint32_t minor);

/**
 * Get version-specific paths as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_version_specific_paths(void);

/**
 * Get special cleanup targets for the current version as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_special_targets(void);

/**
 * Check if the current version has a known bug
 *
 * # Safety
 * - `bug_name` must be a valid null-terminated C string
 */
bool osx_has_known_bug(const char *bug_name);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* OSXCORE_H */
