/* Auto-generated by cbindgen. Do not edit. */

#ifndef OSXCORE_H
#define OSXCORE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Result returned by FFI functions
 */
typedef struct osx_FFIResult {
    bool success;
    char *error_message;
    char *data;
} osx_FFIResult;

/**
 * macOS version representation
 *
 * Stores major, minor, and patch version numbers (e.g., 15.1.0 for Sequoia 15.1)
 */
typedef struct osx_Version {
    uint32_t major;
    uint32_t minor;
    uint32_t patch;
} osx_Version;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the Rust core library
 *
 * # Safety
 * This function initializes the logger and should be called once at startup.
 */
bool osx_core_init(void);

/**
 * Get the version of the Rust core library
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_core_version(void);

/**
 * Analyze a path for cleanup opportunities
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_analyze_path(const char *path);

/**
 * Calculate safety level for a path
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 */
int32_t osx_calculate_safety(const char *path);

/**
 * Check if a path is protected (DANGER level - never delete)
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is protected, false otherwise
 */
bool osx_is_protected(const char *path);

/**
 * Classify a path and return detailed information as JSON
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"path": "...", "level": "...", "level_value": N, "reason": "...", "is_deletable": bool}
 */
struct osx_FFIResult osx_classify_path(const char *path);

/**
 * Validate multiple paths in batch
 *
 * # Safety
 * - `paths_json` must be a valid null-terminated C string containing a JSON array of paths
 * - `cleanup_level` is 1-4 (Light, Normal, Deep, System)
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array of validation results
 */
struct osx_FFIResult osx_validate_batch(const char *paths_json,
                                        int32_t cleanup_level);

/**
 * Validate a single cleanup operation
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - `cleanup_level` is 1-4 (Light, Normal, Deep, System)
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_validate_cleanup(const char *path,
                                          int32_t cleanup_level);

/**
 * Clean a path with the specified cleanup level
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - `cleanup_level` is 1-4 (Light, Normal, Deep, System)
 * - `dry_run` if true, no files will be deleted
 */
struct osx_FFIResult osx_clean_path(const char *path,
                                    int32_t cleanup_level,
                                    bool dry_run);

/**
 * Free a string allocated by Rust
 *
 * # Safety
 * - `s` must be a pointer returned by a Rust FFI function
 * - `s` must not be used after this call
 */
void osx_free_string(char *s);

/**
 * Free an FFIResult
 *
 * # Safety
 * - `result` must be a valid pointer to an FFIResult
 */
void osx_free_result(struct osx_FFIResult *result);

/**
 * Get disk space information for the root filesystem
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded DiskSpace struct
 */
struct osx_FFIResult osx_get_disk_space(void);

/**
 * Analyze home directory and get top N directories by size
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<DirectoryInfo>
 */
struct osx_FFIResult osx_analyze_home(int32_t top_n);

/**
 * Analyze application caches
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<CacheInfo>
 */
struct osx_FFIResult osx_analyze_caches(void);

/**
 * Analyze developer tool components
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded Vec<DeveloperComponentInfo>
 */
struct osx_FFIResult osx_analyze_developer(void);

/**
 * Estimate cleanable space
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded CleanableEstimate
 */
struct osx_FFIResult osx_estimate_cleanable(void);

/**
 * Perform full disk analysis
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON-encoded AnalysisResult
 */
struct osx_FFIResult osx_full_analysis(void);

/**
 * Initialize the deletion logger with optional file output
 *
 * # Safety
 * - `log_path` may be null for memory-only logging
 * - If not null, must be a valid null-terminated C string
 */
struct osx_FFIResult osx_init_logger(const char *log_path);

/**
 * Get all deletion log entries as JSON
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_get_deletion_logs(void);

/**
 * Get deletion log statistics as JSON
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_get_log_stats(void);

/**
 * Clear all deletion logs from memory
 */
void osx_clear_logs(void);

/**
 * Check if a specific application is running
 *
 * # Safety
 * - `app_name` must be a valid null-terminated C string
 * - Returns true if the application is running, false otherwise
 */
bool osx_is_app_running(const char *app_name);

/**
 * Check if a file or directory is in use by any process
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in use, false otherwise
 */
bool osx_is_file_in_use(const char *path);

/**
 * Check if any application related to a cache path is running
 *
 * # Safety
 * - `cache_path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"running": bool, "app_name": "..." or null}
 */
struct osx_FFIResult osx_check_related_app_running(const char *cache_path);

/**
 * Get a list of all running processes
 *
 * # Safety
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array: [{"pid": N, "name": "...", "path": "..." or null}, ...]
 */
struct osx_FFIResult osx_get_running_processes(void);

/**
 * Get processes using a specific file or directory
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array: [{"pid": N, "name": "...", "path": "..." or null}, ...]
 */
struct osx_FFIResult osx_get_processes_using_path(const char *path);

/**
 * Get cache paths associated with a specific application
 *
 * # Safety
 * - `app_name` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON array of paths: ["path1", "path2", ...]
 */
struct osx_FFIResult osx_get_app_cache_paths(const char *app_name);

/**
 * Detect which cloud service (if any) a path belongs to
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"service": "iCloud"|"Dropbox"|"OneDrive"|"Google Drive"|null, "is_cloud_path": bool}
 */
struct osx_FFIResult osx_detect_cloud_service(const char *path);

/**
 * Get detailed cloud sync information for a path
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"service": "...", "status": "...", "path": "...", "is_cloud_path": bool}
 * - Status can be: "Synced", "Syncing", "Pending", "CloudOnly", "LocalOnly", "Error", "NotApplicable"
 */
struct osx_FFIResult osx_get_cloud_sync_info(const char *path);

/**
 * Check if a path is safe to delete from a cloud sync perspective
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 * - Returns JSON: {"safe": bool, "warning": "..." or null}
 * - If not safe, warning explains why (e.g., "File is currently syncing to iCloud")
 */
struct osx_FFIResult osx_is_safe_to_delete_cloud(const char *path);

/**
 * Check if a path is within an iCloud synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in an iCloud location, false otherwise
 */
bool osx_is_icloud_path(const char *path);

/**
 * Check if a path is within a Dropbox synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in a Dropbox location, false otherwise
 */
bool osx_is_dropbox_path(const char *path);

/**
 * Check if a path is within a OneDrive synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in a OneDrive location, false otherwise
 */
bool osx_is_onedrive_path(const char *path);

/**
 * Check if a path is within a Google Drive synced location
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - Returns true if the path is in a Google Drive location, false otherwise
 */
bool osx_is_google_drive_path(const char *path);

/**
 * Get system information as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_system_info(void);

/**
 * Get macOS version string (e.g., "15.1.0")
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_macos_version(void);

/**
 * Get macOS codename (e.g., "Sequoia")
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_macos_codename(void);

/**
 * Get CPU architecture (0=AppleSilicon, 1=Intel, 2=Unknown)
 */
int32_t osx_architecture(void);

/**
 * Check if running on Apple Silicon
 */
bool osx_is_apple_silicon(void);

/**
 * Check if Rosetta 2 is installed
 */
bool osx_is_rosetta_installed(void);

/**
 * Check if current process is running under Rosetta
 */
bool osx_is_running_under_rosetta(void);

/**
 * Check if SIP (System Integrity Protection) is enabled
 */
bool osx_is_sip_enabled(void);

/**
 * Check if version is at least the specified version
 */
bool osx_is_version_at_least(uint32_t major,
                             uint32_t minor);

/**
 * Get version-specific paths as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_version_specific_paths(void);

/**
 * Get special cleanup targets for the current version as JSON
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_special_targets(void);

/**
 * Check if the current version has a known bug
 *
 * # Safety
 * - `bug_name` must be a valid null-terminated C string
 */
bool osx_has_known_bug(const char *bug_name);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* OSXCORE_H */
