/* Auto-generated by cbindgen. Do not edit. */

#ifndef OSXCORE_H
#define OSXCORE_H

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Result returned by FFI functions
 */
typedef struct osx_FFIResult {
    bool success;
    char *error_message;
    char *data;
} osx_FFIResult;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Initialize the Rust core library
 *
 * # Safety
 * This function initializes the logger and should be called once at startup.
 */
bool osx_core_init(void);

/**
 * Get the version of the Rust core library
 *
 * # Safety
 * The returned string must be freed with `osx_free_string`.
 */
char *osx_core_version(void);

/**
 * Analyze a path for cleanup opportunities
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - The returned FFIResult must be freed with `osx_free_result`
 */
struct osx_FFIResult osx_analyze_path(const char *path);

/**
 * Calculate safety level for a path
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 */
int32_t osx_calculate_safety(const char *path);

/**
 * Clean a path with the specified safety level
 *
 * # Safety
 * - `path` must be a valid null-terminated C string
 * - `dry_run` if true, no files will be deleted
 */
struct osx_FFIResult osx_clean_path(const char *path,
                                    int32_t safety_level,
                                    bool dry_run);

/**
 * Free a string allocated by Rust
 *
 * # Safety
 * - `s` must be a pointer returned by a Rust FFI function
 * - `s` must not be used after this call
 */
void osx_free_string(char *s);

/**
 * Free an FFIResult
 *
 * # Safety
 * - `result` must be a valid pointer to an FFIResult
 */
void osx_free_result(struct osx_FFIResult *result);

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif /* OSXCORE_H */
